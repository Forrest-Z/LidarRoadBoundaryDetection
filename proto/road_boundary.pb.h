// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/road_boundary.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2froad_5fboundary_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2froad_5fboundary_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2froad_5fboundary_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2froad_5fboundary_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2froad_5fboundary_2eproto;
namespace RoadBoundary {
class BinReaderMsg;
class BinReaderMsgDefaultTypeInternal;
extern BinReaderMsgDefaultTypeInternal _BinReaderMsg_default_instance_;
class BoundaryPointsMsg;
class BoundaryPointsMsgDefaultTypeInternal;
extern BoundaryPointsMsgDefaultTypeInternal _BoundaryPointsMsg_default_instance_;
class CloudMapperMsg;
class CloudMapperMsgDefaultTypeInternal;
extern CloudMapperMsgDefaultTypeInternal _CloudMapperMsg_default_instance_;
class FeaturePointsMsg;
class FeaturePointsMsgDefaultTypeInternal;
extern FeaturePointsMsgDefaultTypeInternal _FeaturePointsMsg_default_instance_;
class GroundSegmentationMsg;
class GroundSegmentationMsgDefaultTypeInternal;
extern GroundSegmentationMsgDefaultTypeInternal _GroundSegmentationMsg_default_instance_;
class RoadBoundaryMsg;
class RoadBoundaryMsgDefaultTypeInternal;
extern RoadBoundaryMsgDefaultTypeInternal _RoadBoundaryMsg_default_instance_;
}  // namespace RoadBoundary
PROTOBUF_NAMESPACE_OPEN
template<> ::RoadBoundary::BinReaderMsg* Arena::CreateMaybeMessage<::RoadBoundary::BinReaderMsg>(Arena*);
template<> ::RoadBoundary::BoundaryPointsMsg* Arena::CreateMaybeMessage<::RoadBoundary::BoundaryPointsMsg>(Arena*);
template<> ::RoadBoundary::CloudMapperMsg* Arena::CreateMaybeMessage<::RoadBoundary::CloudMapperMsg>(Arena*);
template<> ::RoadBoundary::FeaturePointsMsg* Arena::CreateMaybeMessage<::RoadBoundary::FeaturePointsMsg>(Arena*);
template<> ::RoadBoundary::GroundSegmentationMsg* Arena::CreateMaybeMessage<::RoadBoundary::GroundSegmentationMsg>(Arena*);
template<> ::RoadBoundary::RoadBoundaryMsg* Arena::CreateMaybeMessage<::RoadBoundary::RoadBoundaryMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RoadBoundary {

// ===================================================================

class RoadBoundaryMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadBoundary.RoadBoundaryMsg) */ {
 public:
  RoadBoundaryMsg();
  virtual ~RoadBoundaryMsg();

  RoadBoundaryMsg(const RoadBoundaryMsg& from);
  RoadBoundaryMsg(RoadBoundaryMsg&& from) noexcept
    : RoadBoundaryMsg() {
    *this = ::std::move(from);
  }

  inline RoadBoundaryMsg& operator=(const RoadBoundaryMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadBoundaryMsg& operator=(RoadBoundaryMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoadBoundaryMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadBoundaryMsg* internal_default_instance() {
    return reinterpret_cast<const RoadBoundaryMsg*>(
               &_RoadBoundaryMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoadBoundaryMsg& a, RoadBoundaryMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadBoundaryMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadBoundaryMsg* New() const final {
    return CreateMaybeMessage<RoadBoundaryMsg>(nullptr);
  }

  RoadBoundaryMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadBoundaryMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoadBoundaryMsg& from);
  void MergeFrom(const RoadBoundaryMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadBoundaryMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadBoundary.RoadBoundaryMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2froad_5fboundary_2eproto);
    return ::descriptor_table_proto_2froad_5fboundary_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCloudMapperMsgFieldNumber = 1,
    kBinReaderMsgFieldNumber = 2,
    kGroundSegmentationMsgFieldNumber = 3,
    kFeaturePointsMsgFieldNumber = 4,
    kBoundaryPointsMsgFieldNumber = 5,
  };
  // .RoadBoundary.CloudMapperMsg cloudMapperMsg = 1;
  bool has_cloudmappermsg() const;
  void clear_cloudmappermsg();
  const ::RoadBoundary::CloudMapperMsg& cloudmappermsg() const;
  ::RoadBoundary::CloudMapperMsg* release_cloudmappermsg();
  ::RoadBoundary::CloudMapperMsg* mutable_cloudmappermsg();
  void set_allocated_cloudmappermsg(::RoadBoundary::CloudMapperMsg* cloudmappermsg);

  // .RoadBoundary.BinReaderMsg binReaderMsg = 2;
  bool has_binreadermsg() const;
  void clear_binreadermsg();
  const ::RoadBoundary::BinReaderMsg& binreadermsg() const;
  ::RoadBoundary::BinReaderMsg* release_binreadermsg();
  ::RoadBoundary::BinReaderMsg* mutable_binreadermsg();
  void set_allocated_binreadermsg(::RoadBoundary::BinReaderMsg* binreadermsg);

  // .RoadBoundary.GroundSegmentationMsg groundSegmentationMsg = 3;
  bool has_groundsegmentationmsg() const;
  void clear_groundsegmentationmsg();
  const ::RoadBoundary::GroundSegmentationMsg& groundsegmentationmsg() const;
  ::RoadBoundary::GroundSegmentationMsg* release_groundsegmentationmsg();
  ::RoadBoundary::GroundSegmentationMsg* mutable_groundsegmentationmsg();
  void set_allocated_groundsegmentationmsg(::RoadBoundary::GroundSegmentationMsg* groundsegmentationmsg);

  // .RoadBoundary.FeaturePointsMsg featurePointsMsg = 4;
  bool has_featurepointsmsg() const;
  void clear_featurepointsmsg();
  const ::RoadBoundary::FeaturePointsMsg& featurepointsmsg() const;
  ::RoadBoundary::FeaturePointsMsg* release_featurepointsmsg();
  ::RoadBoundary::FeaturePointsMsg* mutable_featurepointsmsg();
  void set_allocated_featurepointsmsg(::RoadBoundary::FeaturePointsMsg* featurepointsmsg);

  // .RoadBoundary.BoundaryPointsMsg boundaryPointsMsg = 5;
  bool has_boundarypointsmsg() const;
  void clear_boundarypointsmsg();
  const ::RoadBoundary::BoundaryPointsMsg& boundarypointsmsg() const;
  ::RoadBoundary::BoundaryPointsMsg* release_boundarypointsmsg();
  ::RoadBoundary::BoundaryPointsMsg* mutable_boundarypointsmsg();
  void set_allocated_boundarypointsmsg(::RoadBoundary::BoundaryPointsMsg* boundarypointsmsg);

  // @@protoc_insertion_point(class_scope:RoadBoundary.RoadBoundaryMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::RoadBoundary::CloudMapperMsg* cloudmappermsg_;
  ::RoadBoundary::BinReaderMsg* binreadermsg_;
  ::RoadBoundary::GroundSegmentationMsg* groundsegmentationmsg_;
  ::RoadBoundary::FeaturePointsMsg* featurepointsmsg_;
  ::RoadBoundary::BoundaryPointsMsg* boundarypointsmsg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2froad_5fboundary_2eproto;
};
// -------------------------------------------------------------------

class CloudMapperMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadBoundary.CloudMapperMsg) */ {
 public:
  CloudMapperMsg();
  virtual ~CloudMapperMsg();

  CloudMapperMsg(const CloudMapperMsg& from);
  CloudMapperMsg(CloudMapperMsg&& from) noexcept
    : CloudMapperMsg() {
    *this = ::std::move(from);
  }

  inline CloudMapperMsg& operator=(const CloudMapperMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudMapperMsg& operator=(CloudMapperMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CloudMapperMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudMapperMsg* internal_default_instance() {
    return reinterpret_cast<const CloudMapperMsg*>(
               &_CloudMapperMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CloudMapperMsg& a, CloudMapperMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudMapperMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CloudMapperMsg* New() const final {
    return CreateMaybeMessage<CloudMapperMsg>(nullptr);
  }

  CloudMapperMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CloudMapperMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CloudMapperMsg& from);
  void MergeFrom(const CloudMapperMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudMapperMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadBoundary.CloudMapperMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2froad_5fboundary_2eproto);
    return ::descriptor_table_proto_2froad_5fboundary_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerBoundFieldNumber = 1,
    kUpperBoundFieldNumber = 2,
    kNScanRingsFieldNumber = 3,
  };
  // float lowerBound = 1;
  void clear_lowerbound();
  float lowerbound() const;
  void set_lowerbound(float value);

  // float upperBound = 2;
  void clear_upperbound();
  float upperbound() const;
  void set_upperbound(float value);

  // int32 nScanRings = 3;
  void clear_nscanrings();
  ::PROTOBUF_NAMESPACE_ID::int32 nscanrings() const;
  void set_nscanrings(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:RoadBoundary.CloudMapperMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float lowerbound_;
  float upperbound_;
  ::PROTOBUF_NAMESPACE_ID::int32 nscanrings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2froad_5fboundary_2eproto;
};
// -------------------------------------------------------------------

class BinReaderMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadBoundary.BinReaderMsg) */ {
 public:
  BinReaderMsg();
  virtual ~BinReaderMsg();

  BinReaderMsg(const BinReaderMsg& from);
  BinReaderMsg(BinReaderMsg&& from) noexcept
    : BinReaderMsg() {
    *this = ::std::move(from);
  }

  inline BinReaderMsg& operator=(const BinReaderMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinReaderMsg& operator=(BinReaderMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinReaderMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinReaderMsg* internal_default_instance() {
    return reinterpret_cast<const BinReaderMsg*>(
               &_BinReaderMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BinReaderMsg& a, BinReaderMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(BinReaderMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinReaderMsg* New() const final {
    return CreateMaybeMessage<BinReaderMsg>(nullptr);
  }

  BinReaderMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinReaderMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinReaderMsg& from);
  void MergeFrom(const BinReaderMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinReaderMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadBoundary.BinReaderMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2froad_5fboundary_2eproto);
    return ::descriptor_table_proto_2froad_5fboundary_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinDirFieldNumber = 1,
    kFrameNumFieldNumber = 2,
  };
  // string binDir = 1;
  void clear_bindir();
  const std::string& bindir() const;
  void set_bindir(const std::string& value);
  void set_bindir(std::string&& value);
  void set_bindir(const char* value);
  void set_bindir(const char* value, size_t size);
  std::string* mutable_bindir();
  std::string* release_bindir();
  void set_allocated_bindir(std::string* bindir);

  // int32 frameNum = 2;
  void clear_framenum();
  ::PROTOBUF_NAMESPACE_ID::int32 framenum() const;
  void set_framenum(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:RoadBoundary.BinReaderMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bindir_;
  ::PROTOBUF_NAMESPACE_ID::int32 framenum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2froad_5fboundary_2eproto;
};
// -------------------------------------------------------------------

class GroundSegmentationMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadBoundary.GroundSegmentationMsg) */ {
 public:
  GroundSegmentationMsg();
  virtual ~GroundSegmentationMsg();

  GroundSegmentationMsg(const GroundSegmentationMsg& from);
  GroundSegmentationMsg(GroundSegmentationMsg&& from) noexcept
    : GroundSegmentationMsg() {
    *this = ::std::move(from);
  }

  inline GroundSegmentationMsg& operator=(const GroundSegmentationMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroundSegmentationMsg& operator=(GroundSegmentationMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GroundSegmentationMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroundSegmentationMsg* internal_default_instance() {
    return reinterpret_cast<const GroundSegmentationMsg*>(
               &_GroundSegmentationMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GroundSegmentationMsg& a, GroundSegmentationMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GroundSegmentationMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GroundSegmentationMsg* New() const final {
    return CreateMaybeMessage<GroundSegmentationMsg>(nullptr);
  }

  GroundSegmentationMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GroundSegmentationMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GroundSegmentationMsg& from);
  void MergeFrom(const GroundSegmentationMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroundSegmentationMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadBoundary.GroundSegmentationMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2froad_5fboundary_2eproto);
    return ::descriptor_table_proto_2froad_5fboundary_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegThresFieldNumber = 1,
  };
  // float segThres = 1;
  void clear_segthres();
  float segthres() const;
  void set_segthres(float value);

  // @@protoc_insertion_point(class_scope:RoadBoundary.GroundSegmentationMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float segthres_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2froad_5fboundary_2eproto;
};
// -------------------------------------------------------------------

class FeaturePointsMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadBoundary.FeaturePointsMsg) */ {
 public:
  FeaturePointsMsg();
  virtual ~FeaturePointsMsg();

  FeaturePointsMsg(const FeaturePointsMsg& from);
  FeaturePointsMsg(FeaturePointsMsg&& from) noexcept
    : FeaturePointsMsg() {
    *this = ::std::move(from);
  }

  inline FeaturePointsMsg& operator=(const FeaturePointsMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeaturePointsMsg& operator=(FeaturePointsMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeaturePointsMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeaturePointsMsg* internal_default_instance() {
    return reinterpret_cast<const FeaturePointsMsg*>(
               &_FeaturePointsMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FeaturePointsMsg& a, FeaturePointsMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(FeaturePointsMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeaturePointsMsg* New() const final {
    return CreateMaybeMessage<FeaturePointsMsg>(nullptr);
  }

  FeaturePointsMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeaturePointsMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeaturePointsMsg& from);
  void MergeFrom(const FeaturePointsMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeaturePointsMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadBoundary.FeaturePointsMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2froad_5fboundary_2eproto);
    return ::descriptor_table_proto_2froad_5fboundary_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightMaxThresFieldNumber = 1,
    kHeightMinThresFieldNumber = 2,
    kHeightRegionFieldNumber = 3,
    kHeightSigmaThreFieldNumber = 4,
    kCurvatureRegionFieldNumber = 5,
    kCurvatureThresFieldNumber = 6,
    kDistanceHorizonThresFieldNumber = 7,
    kDistanceVerticalThresFieldNumber = 8,
    kAngularResFieldNumber = 9,
    kUseVerticleFieldNumber = 10,
    kUseHorizonFieldNumber = 11,
  };
  // float heightMaxThres = 1;
  void clear_heightmaxthres();
  float heightmaxthres() const;
  void set_heightmaxthres(float value);

  // float heightMinThres = 2;
  void clear_heightminthres();
  float heightminthres() const;
  void set_heightminthres(float value);

  // int32 heightRegion = 3;
  void clear_heightregion();
  ::PROTOBUF_NAMESPACE_ID::int32 heightregion() const;
  void set_heightregion(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float heightSigmaThre = 4;
  void clear_heightsigmathre();
  float heightsigmathre() const;
  void set_heightsigmathre(float value);

  // int32 curvatureRegion = 5;
  void clear_curvatureregion();
  ::PROTOBUF_NAMESPACE_ID::int32 curvatureregion() const;
  void set_curvatureregion(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float curvatureThres = 6;
  void clear_curvaturethres();
  float curvaturethres() const;
  void set_curvaturethres(float value);

  // float distanceHorizonThres = 7;
  void clear_distancehorizonthres();
  float distancehorizonthres() const;
  void set_distancehorizonthres(float value);

  // float distanceVerticalThres = 8;
  void clear_distanceverticalthres();
  float distanceverticalthres() const;
  void set_distanceverticalthres(float value);

  // float angularRes = 9;
  void clear_angularres();
  float angularres() const;
  void set_angularres(float value);

  // bool useVerticle = 10;
  void clear_useverticle();
  bool useverticle() const;
  void set_useverticle(bool value);

  // bool useHorizon = 11;
  void clear_usehorizon();
  bool usehorizon() const;
  void set_usehorizon(bool value);

  // @@protoc_insertion_point(class_scope:RoadBoundary.FeaturePointsMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float heightmaxthres_;
  float heightminthres_;
  ::PROTOBUF_NAMESPACE_ID::int32 heightregion_;
  float heightsigmathre_;
  ::PROTOBUF_NAMESPACE_ID::int32 curvatureregion_;
  float curvaturethres_;
  float distancehorizonthres_;
  float distanceverticalthres_;
  float angularres_;
  bool useverticle_;
  bool usehorizon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2froad_5fboundary_2eproto;
};
// -------------------------------------------------------------------

class BoundaryPointsMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoadBoundary.BoundaryPointsMsg) */ {
 public:
  BoundaryPointsMsg();
  virtual ~BoundaryPointsMsg();

  BoundaryPointsMsg(const BoundaryPointsMsg& from);
  BoundaryPointsMsg(BoundaryPointsMsg&& from) noexcept
    : BoundaryPointsMsg() {
    *this = ::std::move(from);
  }

  inline BoundaryPointsMsg& operator=(const BoundaryPointsMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundaryPointsMsg& operator=(BoundaryPointsMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundaryPointsMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundaryPointsMsg* internal_default_instance() {
    return reinterpret_cast<const BoundaryPointsMsg*>(
               &_BoundaryPointsMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BoundaryPointsMsg& a, BoundaryPointsMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundaryPointsMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundaryPointsMsg* New() const final {
    return CreateMaybeMessage<BoundaryPointsMsg>(nullptr);
  }

  BoundaryPointsMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundaryPointsMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundaryPointsMsg& from);
  void MergeFrom(const BoundaryPointsMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundaryPointsMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoadBoundary.BoundaryPointsMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2froad_5fboundary_2eproto);
    return ::descriptor_table_proto_2froad_5fboundary_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarThresFieldNumber = 1,
    kMeanThresFieldNumber = 2,
    kGridNumFieldNumber = 3,
    kGridResFieldNumber = 4,
    kCurveFitThresFieldNumber = 5,
    kUseCurveRansacFieldNumber = 6,
  };
  // float varThres = 1;
  void clear_varthres();
  float varthres() const;
  void set_varthres(float value);

  // float meanThres = 2;
  void clear_meanthres();
  float meanthres() const;
  void set_meanthres(float value);

  // int32 gridNum = 3;
  void clear_gridnum();
  ::PROTOBUF_NAMESPACE_ID::int32 gridnum() const;
  void set_gridnum(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float gridRes = 4;
  void clear_gridres();
  float gridres() const;
  void set_gridres(float value);

  // float curveFitThres = 5;
  void clear_curvefitthres();
  float curvefitthres() const;
  void set_curvefitthres(float value);

  // bool useCurveRansac = 6;
  void clear_usecurveransac();
  bool usecurveransac() const;
  void set_usecurveransac(bool value);

  // @@protoc_insertion_point(class_scope:RoadBoundary.BoundaryPointsMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float varthres_;
  float meanthres_;
  ::PROTOBUF_NAMESPACE_ID::int32 gridnum_;
  float gridres_;
  float curvefitthres_;
  bool usecurveransac_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2froad_5fboundary_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoadBoundaryMsg

// .RoadBoundary.CloudMapperMsg cloudMapperMsg = 1;
inline bool RoadBoundaryMsg::has_cloudmappermsg() const {
  return this != internal_default_instance() && cloudmappermsg_ != nullptr;
}
inline void RoadBoundaryMsg::clear_cloudmappermsg() {
  if (GetArenaNoVirtual() == nullptr && cloudmappermsg_ != nullptr) {
    delete cloudmappermsg_;
  }
  cloudmappermsg_ = nullptr;
}
inline const ::RoadBoundary::CloudMapperMsg& RoadBoundaryMsg::cloudmappermsg() const {
  const ::RoadBoundary::CloudMapperMsg* p = cloudmappermsg_;
  // @@protoc_insertion_point(field_get:RoadBoundary.RoadBoundaryMsg.cloudMapperMsg)
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadBoundary::CloudMapperMsg*>(
      &::RoadBoundary::_CloudMapperMsg_default_instance_);
}
inline ::RoadBoundary::CloudMapperMsg* RoadBoundaryMsg::release_cloudmappermsg() {
  // @@protoc_insertion_point(field_release:RoadBoundary.RoadBoundaryMsg.cloudMapperMsg)
  
  ::RoadBoundary::CloudMapperMsg* temp = cloudmappermsg_;
  cloudmappermsg_ = nullptr;
  return temp;
}
inline ::RoadBoundary::CloudMapperMsg* RoadBoundaryMsg::mutable_cloudmappermsg() {
  
  if (cloudmappermsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadBoundary::CloudMapperMsg>(GetArenaNoVirtual());
    cloudmappermsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadBoundary.RoadBoundaryMsg.cloudMapperMsg)
  return cloudmappermsg_;
}
inline void RoadBoundaryMsg::set_allocated_cloudmappermsg(::RoadBoundary::CloudMapperMsg* cloudmappermsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cloudmappermsg_;
  }
  if (cloudmappermsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cloudmappermsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cloudmappermsg, submessage_arena);
    }
    
  } else {
    
  }
  cloudmappermsg_ = cloudmappermsg;
  // @@protoc_insertion_point(field_set_allocated:RoadBoundary.RoadBoundaryMsg.cloudMapperMsg)
}

// .RoadBoundary.BinReaderMsg binReaderMsg = 2;
inline bool RoadBoundaryMsg::has_binreadermsg() const {
  return this != internal_default_instance() && binreadermsg_ != nullptr;
}
inline void RoadBoundaryMsg::clear_binreadermsg() {
  if (GetArenaNoVirtual() == nullptr && binreadermsg_ != nullptr) {
    delete binreadermsg_;
  }
  binreadermsg_ = nullptr;
}
inline const ::RoadBoundary::BinReaderMsg& RoadBoundaryMsg::binreadermsg() const {
  const ::RoadBoundary::BinReaderMsg* p = binreadermsg_;
  // @@protoc_insertion_point(field_get:RoadBoundary.RoadBoundaryMsg.binReaderMsg)
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadBoundary::BinReaderMsg*>(
      &::RoadBoundary::_BinReaderMsg_default_instance_);
}
inline ::RoadBoundary::BinReaderMsg* RoadBoundaryMsg::release_binreadermsg() {
  // @@protoc_insertion_point(field_release:RoadBoundary.RoadBoundaryMsg.binReaderMsg)
  
  ::RoadBoundary::BinReaderMsg* temp = binreadermsg_;
  binreadermsg_ = nullptr;
  return temp;
}
inline ::RoadBoundary::BinReaderMsg* RoadBoundaryMsg::mutable_binreadermsg() {
  
  if (binreadermsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadBoundary::BinReaderMsg>(GetArenaNoVirtual());
    binreadermsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadBoundary.RoadBoundaryMsg.binReaderMsg)
  return binreadermsg_;
}
inline void RoadBoundaryMsg::set_allocated_binreadermsg(::RoadBoundary::BinReaderMsg* binreadermsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete binreadermsg_;
  }
  if (binreadermsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      binreadermsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binreadermsg, submessage_arena);
    }
    
  } else {
    
  }
  binreadermsg_ = binreadermsg;
  // @@protoc_insertion_point(field_set_allocated:RoadBoundary.RoadBoundaryMsg.binReaderMsg)
}

// .RoadBoundary.GroundSegmentationMsg groundSegmentationMsg = 3;
inline bool RoadBoundaryMsg::has_groundsegmentationmsg() const {
  return this != internal_default_instance() && groundsegmentationmsg_ != nullptr;
}
inline void RoadBoundaryMsg::clear_groundsegmentationmsg() {
  if (GetArenaNoVirtual() == nullptr && groundsegmentationmsg_ != nullptr) {
    delete groundsegmentationmsg_;
  }
  groundsegmentationmsg_ = nullptr;
}
inline const ::RoadBoundary::GroundSegmentationMsg& RoadBoundaryMsg::groundsegmentationmsg() const {
  const ::RoadBoundary::GroundSegmentationMsg* p = groundsegmentationmsg_;
  // @@protoc_insertion_point(field_get:RoadBoundary.RoadBoundaryMsg.groundSegmentationMsg)
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadBoundary::GroundSegmentationMsg*>(
      &::RoadBoundary::_GroundSegmentationMsg_default_instance_);
}
inline ::RoadBoundary::GroundSegmentationMsg* RoadBoundaryMsg::release_groundsegmentationmsg() {
  // @@protoc_insertion_point(field_release:RoadBoundary.RoadBoundaryMsg.groundSegmentationMsg)
  
  ::RoadBoundary::GroundSegmentationMsg* temp = groundsegmentationmsg_;
  groundsegmentationmsg_ = nullptr;
  return temp;
}
inline ::RoadBoundary::GroundSegmentationMsg* RoadBoundaryMsg::mutable_groundsegmentationmsg() {
  
  if (groundsegmentationmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadBoundary::GroundSegmentationMsg>(GetArenaNoVirtual());
    groundsegmentationmsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadBoundary.RoadBoundaryMsg.groundSegmentationMsg)
  return groundsegmentationmsg_;
}
inline void RoadBoundaryMsg::set_allocated_groundsegmentationmsg(::RoadBoundary::GroundSegmentationMsg* groundsegmentationmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete groundsegmentationmsg_;
  }
  if (groundsegmentationmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      groundsegmentationmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, groundsegmentationmsg, submessage_arena);
    }
    
  } else {
    
  }
  groundsegmentationmsg_ = groundsegmentationmsg;
  // @@protoc_insertion_point(field_set_allocated:RoadBoundary.RoadBoundaryMsg.groundSegmentationMsg)
}

// .RoadBoundary.FeaturePointsMsg featurePointsMsg = 4;
inline bool RoadBoundaryMsg::has_featurepointsmsg() const {
  return this != internal_default_instance() && featurepointsmsg_ != nullptr;
}
inline void RoadBoundaryMsg::clear_featurepointsmsg() {
  if (GetArenaNoVirtual() == nullptr && featurepointsmsg_ != nullptr) {
    delete featurepointsmsg_;
  }
  featurepointsmsg_ = nullptr;
}
inline const ::RoadBoundary::FeaturePointsMsg& RoadBoundaryMsg::featurepointsmsg() const {
  const ::RoadBoundary::FeaturePointsMsg* p = featurepointsmsg_;
  // @@protoc_insertion_point(field_get:RoadBoundary.RoadBoundaryMsg.featurePointsMsg)
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadBoundary::FeaturePointsMsg*>(
      &::RoadBoundary::_FeaturePointsMsg_default_instance_);
}
inline ::RoadBoundary::FeaturePointsMsg* RoadBoundaryMsg::release_featurepointsmsg() {
  // @@protoc_insertion_point(field_release:RoadBoundary.RoadBoundaryMsg.featurePointsMsg)
  
  ::RoadBoundary::FeaturePointsMsg* temp = featurepointsmsg_;
  featurepointsmsg_ = nullptr;
  return temp;
}
inline ::RoadBoundary::FeaturePointsMsg* RoadBoundaryMsg::mutable_featurepointsmsg() {
  
  if (featurepointsmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadBoundary::FeaturePointsMsg>(GetArenaNoVirtual());
    featurepointsmsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadBoundary.RoadBoundaryMsg.featurePointsMsg)
  return featurepointsmsg_;
}
inline void RoadBoundaryMsg::set_allocated_featurepointsmsg(::RoadBoundary::FeaturePointsMsg* featurepointsmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete featurepointsmsg_;
  }
  if (featurepointsmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      featurepointsmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featurepointsmsg, submessage_arena);
    }
    
  } else {
    
  }
  featurepointsmsg_ = featurepointsmsg;
  // @@protoc_insertion_point(field_set_allocated:RoadBoundary.RoadBoundaryMsg.featurePointsMsg)
}

// .RoadBoundary.BoundaryPointsMsg boundaryPointsMsg = 5;
inline bool RoadBoundaryMsg::has_boundarypointsmsg() const {
  return this != internal_default_instance() && boundarypointsmsg_ != nullptr;
}
inline void RoadBoundaryMsg::clear_boundarypointsmsg() {
  if (GetArenaNoVirtual() == nullptr && boundarypointsmsg_ != nullptr) {
    delete boundarypointsmsg_;
  }
  boundarypointsmsg_ = nullptr;
}
inline const ::RoadBoundary::BoundaryPointsMsg& RoadBoundaryMsg::boundarypointsmsg() const {
  const ::RoadBoundary::BoundaryPointsMsg* p = boundarypointsmsg_;
  // @@protoc_insertion_point(field_get:RoadBoundary.RoadBoundaryMsg.boundaryPointsMsg)
  return p != nullptr ? *p : *reinterpret_cast<const ::RoadBoundary::BoundaryPointsMsg*>(
      &::RoadBoundary::_BoundaryPointsMsg_default_instance_);
}
inline ::RoadBoundary::BoundaryPointsMsg* RoadBoundaryMsg::release_boundarypointsmsg() {
  // @@protoc_insertion_point(field_release:RoadBoundary.RoadBoundaryMsg.boundaryPointsMsg)
  
  ::RoadBoundary::BoundaryPointsMsg* temp = boundarypointsmsg_;
  boundarypointsmsg_ = nullptr;
  return temp;
}
inline ::RoadBoundary::BoundaryPointsMsg* RoadBoundaryMsg::mutable_boundarypointsmsg() {
  
  if (boundarypointsmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::RoadBoundary::BoundaryPointsMsg>(GetArenaNoVirtual());
    boundarypointsmsg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadBoundary.RoadBoundaryMsg.boundaryPointsMsg)
  return boundarypointsmsg_;
}
inline void RoadBoundaryMsg::set_allocated_boundarypointsmsg(::RoadBoundary::BoundaryPointsMsg* boundarypointsmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete boundarypointsmsg_;
  }
  if (boundarypointsmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      boundarypointsmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundarypointsmsg, submessage_arena);
    }
    
  } else {
    
  }
  boundarypointsmsg_ = boundarypointsmsg;
  // @@protoc_insertion_point(field_set_allocated:RoadBoundary.RoadBoundaryMsg.boundaryPointsMsg)
}

// -------------------------------------------------------------------

// CloudMapperMsg

// float lowerBound = 1;
inline void CloudMapperMsg::clear_lowerbound() {
  lowerbound_ = 0;
}
inline float CloudMapperMsg::lowerbound() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.CloudMapperMsg.lowerBound)
  return lowerbound_;
}
inline void CloudMapperMsg::set_lowerbound(float value) {
  
  lowerbound_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.CloudMapperMsg.lowerBound)
}

// float upperBound = 2;
inline void CloudMapperMsg::clear_upperbound() {
  upperbound_ = 0;
}
inline float CloudMapperMsg::upperbound() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.CloudMapperMsg.upperBound)
  return upperbound_;
}
inline void CloudMapperMsg::set_upperbound(float value) {
  
  upperbound_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.CloudMapperMsg.upperBound)
}

// int32 nScanRings = 3;
inline void CloudMapperMsg::clear_nscanrings() {
  nscanrings_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CloudMapperMsg::nscanrings() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.CloudMapperMsg.nScanRings)
  return nscanrings_;
}
inline void CloudMapperMsg::set_nscanrings(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nscanrings_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.CloudMapperMsg.nScanRings)
}

// -------------------------------------------------------------------

// BinReaderMsg

// string binDir = 1;
inline void BinReaderMsg::clear_bindir() {
  bindir_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BinReaderMsg::bindir() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BinReaderMsg.binDir)
  return bindir_.GetNoArena();
}
inline void BinReaderMsg::set_bindir(const std::string& value) {
  
  bindir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoadBoundary.BinReaderMsg.binDir)
}
inline void BinReaderMsg::set_bindir(std::string&& value) {
  
  bindir_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RoadBoundary.BinReaderMsg.binDir)
}
inline void BinReaderMsg::set_bindir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bindir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoadBoundary.BinReaderMsg.binDir)
}
inline void BinReaderMsg::set_bindir(const char* value, size_t size) {
  
  bindir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoadBoundary.BinReaderMsg.binDir)
}
inline std::string* BinReaderMsg::mutable_bindir() {
  
  // @@protoc_insertion_point(field_mutable:RoadBoundary.BinReaderMsg.binDir)
  return bindir_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BinReaderMsg::release_bindir() {
  // @@protoc_insertion_point(field_release:RoadBoundary.BinReaderMsg.binDir)
  
  return bindir_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BinReaderMsg::set_allocated_bindir(std::string* bindir) {
  if (bindir != nullptr) {
    
  } else {
    
  }
  bindir_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bindir);
  // @@protoc_insertion_point(field_set_allocated:RoadBoundary.BinReaderMsg.binDir)
}

// int32 frameNum = 2;
inline void BinReaderMsg::clear_framenum() {
  framenum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BinReaderMsg::framenum() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BinReaderMsg.frameNum)
  return framenum_;
}
inline void BinReaderMsg::set_framenum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  framenum_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BinReaderMsg.frameNum)
}

// -------------------------------------------------------------------

// GroundSegmentationMsg

// float segThres = 1;
inline void GroundSegmentationMsg::clear_segthres() {
  segthres_ = 0;
}
inline float GroundSegmentationMsg::segthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.GroundSegmentationMsg.segThres)
  return segthres_;
}
inline void GroundSegmentationMsg::set_segthres(float value) {
  
  segthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.GroundSegmentationMsg.segThres)
}

// -------------------------------------------------------------------

// FeaturePointsMsg

// float heightMaxThres = 1;
inline void FeaturePointsMsg::clear_heightmaxthres() {
  heightmaxthres_ = 0;
}
inline float FeaturePointsMsg::heightmaxthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.heightMaxThres)
  return heightmaxthres_;
}
inline void FeaturePointsMsg::set_heightmaxthres(float value) {
  
  heightmaxthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.heightMaxThres)
}

// float heightMinThres = 2;
inline void FeaturePointsMsg::clear_heightminthres() {
  heightminthres_ = 0;
}
inline float FeaturePointsMsg::heightminthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.heightMinThres)
  return heightminthres_;
}
inline void FeaturePointsMsg::set_heightminthres(float value) {
  
  heightminthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.heightMinThres)
}

// int32 heightRegion = 3;
inline void FeaturePointsMsg::clear_heightregion() {
  heightregion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FeaturePointsMsg::heightregion() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.heightRegion)
  return heightregion_;
}
inline void FeaturePointsMsg::set_heightregion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  heightregion_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.heightRegion)
}

// float heightSigmaThre = 4;
inline void FeaturePointsMsg::clear_heightsigmathre() {
  heightsigmathre_ = 0;
}
inline float FeaturePointsMsg::heightsigmathre() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.heightSigmaThre)
  return heightsigmathre_;
}
inline void FeaturePointsMsg::set_heightsigmathre(float value) {
  
  heightsigmathre_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.heightSigmaThre)
}

// int32 curvatureRegion = 5;
inline void FeaturePointsMsg::clear_curvatureregion() {
  curvatureregion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FeaturePointsMsg::curvatureregion() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.curvatureRegion)
  return curvatureregion_;
}
inline void FeaturePointsMsg::set_curvatureregion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curvatureregion_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.curvatureRegion)
}

// float curvatureThres = 6;
inline void FeaturePointsMsg::clear_curvaturethres() {
  curvaturethres_ = 0;
}
inline float FeaturePointsMsg::curvaturethres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.curvatureThres)
  return curvaturethres_;
}
inline void FeaturePointsMsg::set_curvaturethres(float value) {
  
  curvaturethres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.curvatureThres)
}

// float distanceHorizonThres = 7;
inline void FeaturePointsMsg::clear_distancehorizonthres() {
  distancehorizonthres_ = 0;
}
inline float FeaturePointsMsg::distancehorizonthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.distanceHorizonThres)
  return distancehorizonthres_;
}
inline void FeaturePointsMsg::set_distancehorizonthres(float value) {
  
  distancehorizonthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.distanceHorizonThres)
}

// float distanceVerticalThres = 8;
inline void FeaturePointsMsg::clear_distanceverticalthres() {
  distanceverticalthres_ = 0;
}
inline float FeaturePointsMsg::distanceverticalthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.distanceVerticalThres)
  return distanceverticalthres_;
}
inline void FeaturePointsMsg::set_distanceverticalthres(float value) {
  
  distanceverticalthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.distanceVerticalThres)
}

// float angularRes = 9;
inline void FeaturePointsMsg::clear_angularres() {
  angularres_ = 0;
}
inline float FeaturePointsMsg::angularres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.angularRes)
  return angularres_;
}
inline void FeaturePointsMsg::set_angularres(float value) {
  
  angularres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.angularRes)
}

// bool useVerticle = 10;
inline void FeaturePointsMsg::clear_useverticle() {
  useverticle_ = false;
}
inline bool FeaturePointsMsg::useverticle() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.useVerticle)
  return useverticle_;
}
inline void FeaturePointsMsg::set_useverticle(bool value) {
  
  useverticle_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.useVerticle)
}

// bool useHorizon = 11;
inline void FeaturePointsMsg::clear_usehorizon() {
  usehorizon_ = false;
}
inline bool FeaturePointsMsg::usehorizon() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.FeaturePointsMsg.useHorizon)
  return usehorizon_;
}
inline void FeaturePointsMsg::set_usehorizon(bool value) {
  
  usehorizon_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.FeaturePointsMsg.useHorizon)
}

// -------------------------------------------------------------------

// BoundaryPointsMsg

// float varThres = 1;
inline void BoundaryPointsMsg::clear_varthres() {
  varthres_ = 0;
}
inline float BoundaryPointsMsg::varthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BoundaryPointsMsg.varThres)
  return varthres_;
}
inline void BoundaryPointsMsg::set_varthres(float value) {
  
  varthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BoundaryPointsMsg.varThres)
}

// float meanThres = 2;
inline void BoundaryPointsMsg::clear_meanthres() {
  meanthres_ = 0;
}
inline float BoundaryPointsMsg::meanthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BoundaryPointsMsg.meanThres)
  return meanthres_;
}
inline void BoundaryPointsMsg::set_meanthres(float value) {
  
  meanthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BoundaryPointsMsg.meanThres)
}

// int32 gridNum = 3;
inline void BoundaryPointsMsg::clear_gridnum() {
  gridnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoundaryPointsMsg::gridnum() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BoundaryPointsMsg.gridNum)
  return gridnum_;
}
inline void BoundaryPointsMsg::set_gridnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gridnum_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BoundaryPointsMsg.gridNum)
}

// float gridRes = 4;
inline void BoundaryPointsMsg::clear_gridres() {
  gridres_ = 0;
}
inline float BoundaryPointsMsg::gridres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BoundaryPointsMsg.gridRes)
  return gridres_;
}
inline void BoundaryPointsMsg::set_gridres(float value) {
  
  gridres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BoundaryPointsMsg.gridRes)
}

// float curveFitThres = 5;
inline void BoundaryPointsMsg::clear_curvefitthres() {
  curvefitthres_ = 0;
}
inline float BoundaryPointsMsg::curvefitthres() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BoundaryPointsMsg.curveFitThres)
  return curvefitthres_;
}
inline void BoundaryPointsMsg::set_curvefitthres(float value) {
  
  curvefitthres_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BoundaryPointsMsg.curveFitThres)
}

// bool useCurveRansac = 6;
inline void BoundaryPointsMsg::clear_usecurveransac() {
  usecurveransac_ = false;
}
inline bool BoundaryPointsMsg::usecurveransac() const {
  // @@protoc_insertion_point(field_get:RoadBoundary.BoundaryPointsMsg.useCurveRansac)
  return usecurveransac_;
}
inline void BoundaryPointsMsg::set_usecurveransac(bool value) {
  
  usecurveransac_ = value;
  // @@protoc_insertion_point(field_set:RoadBoundary.BoundaryPointsMsg.useCurveRansac)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoadBoundary

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2froad_5fboundary_2eproto
